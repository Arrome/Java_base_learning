# 并发 线程

* 线程间通信机制：
    1. 共享内存
    2. 消息传递
* Java并发安全核心：对状态访问（ **共享的**和 **可变的**状态的访问）进行管理,防止数据上发生不受控的并发访问

    > java中， __堆内存在线程之间共享__(包括 所有实例域、静态域、数据元素等)
    > **无状态对象一定是线程安全的**
    > **无状态类中添加一个状态时，如果状态完全由线程安全的对象来管理，这个类仍然是线程安全的**

  * java同步机制：
    * 独占加锁方式synchronized，
    * volatile变量，
    * 显式锁，
    * 原子变量

#### 竞态条件:
概念：某个计算的正确性取决于多个线程的交替执行时序时，就会发生竞态条件（常见类型：先检查后执行）

####活跃性和性能:
* 当执行时间较长的计算或可能无法快速完成的操作时，一定不要持有锁（权衡安全性/简单性/性能）

####可见性:
* 指令重排序，导致读取到无效或失效数据
* 非原子的64位操作，例如：Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，非volatile类型的64位数值变量（double，long）JVM允许将64位读操作或写操作分解为两个32位的操作。很可能会读取到某个值的高32位和另一个值的低32位
> 访问某个共享且可变变量时 **要求所有线程在同一个锁上同步**，确保某个线程写入该变量的值对于其他线程来说都是可见的
> 加锁机制既可以确保可见性又可以确保原子性，而 **volatile变量只能确保可见性**

线程阻塞/非阻塞
-------------
**Java线程与操作系统线程**：Java线程是映射到操作系统原生线程之上，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在用户态与内核态之间切换，切换会消耗大量系统资源
（用户态和内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作）